{"ast":null,"code":"/**\n * Parse layer options\n * @private\n * @param {object|*} layer The layer to parse.\n * @return {string} layer transformation string\n */\nimport { isObject } from \"../utils/isObject.js\";\nimport { base64Encode } from \"../../internal/utils/base64Encode.js\";\nimport { LAYER_KEYWORD_PARAMS } from \"../consts.js\";\nimport { smartEscape } from \"../utils/smartEscape.js\";\nimport TextLayer from \"../legacyLayer/textlayer.js\";\nimport Layer from \"../legacyLayer/layer.js\";\nexport function textStyle(layer) {\n  const keywords = [];\n  let style = \"\";\n  Object.keys(LAYER_KEYWORD_PARAMS).forEach(attr => {\n    let default_value = LAYER_KEYWORD_PARAMS[attr];\n    let attr_value = layer[attr] || default_value;\n\n    if (attr_value !== default_value) {\n      keywords.push(attr_value);\n    }\n  });\n  Object.keys(layer).forEach(attr => {\n    if (attr === \"letter_spacing\" || attr === \"line_spacing\") {\n      keywords.push(`${attr}_${layer[attr]}`);\n    }\n\n    if (attr === \"font_hinting\") {\n      keywords.push(`${attr.split(\"_\").pop()}_${layer[attr]}`);\n    }\n\n    if (attr === \"font_antialiasing\") {\n      keywords.push(`antialias_${layer[attr]}`);\n    }\n  });\n\n  if (layer.hasOwnProperty(\"font_size\" || \"font_family\") || !keywords || keywords.length === 0) {\n    if (!layer.font_size) throw `Must supply font_size for text in overlay/underlay`;\n    if (!layer.font_family) throw `Must supply font_family for text in overlay/underlay`;\n    keywords.unshift(layer.font_size);\n    keywords.unshift(layer.font_family);\n    style = keywords.filter(a => a).join(\"_\");\n  }\n\n  return style;\n}\nexport function processLayer(layer) {\n  if (layer instanceof TextLayer || layer instanceof Layer) {\n    return layer.toString();\n  }\n\n  let result = '';\n\n  if (isObject(layer)) {\n    if (layer.resource_type === \"fetch\" || layer.url != null) {\n      result = `fetch:${base64Encode(layer.url)}`;\n    } else {\n      let public_id = layer.public_id;\n      let format = layer.format;\n      let resource_type = layer.resource_type || \"image\";\n      let type = layer.type || \"upload\";\n      let text = layer.text;\n      let style = null;\n      let components = [];\n      const noPublicId = !public_id || public_id.length === 0;\n\n      if (!noPublicId) {\n        public_id = public_id.replace(new RegExp(\"/\", 'g'), \":\");\n\n        if (format != null) {\n          public_id = `${public_id}.${format}`;\n        }\n      }\n\n      if ((!text || text.length === 0) && resource_type !== \"text\") {\n        if (noPublicId) {\n          throw \"Must supply public_id for resource_type layer_parameter\";\n        }\n\n        if (resource_type === \"subtitles\") {\n          style = textStyle(layer);\n        }\n      } else {\n        resource_type = \"text\";\n        type = null; // type is ignored for text layers\n\n        style = textStyle(layer);\n\n        if (text && text.length >= 0) {\n          const noStyle = !style;\n\n          if (!(noPublicId || noStyle) || noPublicId && noStyle) {\n            throw \"Must supply either style parameters or a public_id when providing text parameter in a text overlay/underlay\";\n          }\n\n          let re = /\\$\\([a-zA-Z]\\w*\\)/g;\n          let start = 0;\n          let textSource = smartEscape(decodeURIComponent(text), /[,\\/]/g);\n          text = \"\";\n\n          for (let res = re.exec(textSource); res; res = re.exec(textSource)) {\n            text += smartEscape(textSource.slice(start, res.index));\n            text += res[0];\n            start = res.index + res[0].length;\n          }\n\n          text += encodeURIComponent(textSource.slice(start));\n        }\n      }\n\n      if (resource_type !== \"image\") {\n        components.push(resource_type);\n      }\n\n      if (type !== \"upload\") {\n        components.push(type);\n      }\n\n      components.push(style);\n      components.push(public_id);\n      components.push(text);\n      result = components.filter(a => a).join(\":\");\n    }\n  } else if (/^fetch:.+/.test(layer)) {\n    result = `fetch:${base64Encode(layer.substr(6))}`;\n  } else {\n    result = layer;\n  }\n\n  return result;\n}","map":{"version":3,"names":["isObject","base64Encode","LAYER_KEYWORD_PARAMS","smartEscape","TextLayer","Layer","textStyle","layer","keywords","style","Object","keys","forEach","attr","default_value","attr_value","push","split","pop","hasOwnProperty","length","font_size","font_family","unshift","filter","a","join","processLayer","toString","result","resource_type","url","public_id","format","type","text","components","noPublicId","replace","RegExp","noStyle","re","start","textSource","decodeURIComponent","res","exec","slice","index","encodeURIComponent","test","substr"],"sources":["C:/Users/DELL/OneDrive/Desktop/New folder (2)/New folder/node_modules/@cloudinary/url-gen/backwards/transformationProcessing/processLayer.js"],"sourcesContent":["/**\n * Parse layer options\n * @private\n * @param {object|*} layer The layer to parse.\n * @return {string} layer transformation string\n */\nimport { isObject } from \"../utils/isObject.js\";\nimport { base64Encode } from \"../../internal/utils/base64Encode.js\";\nimport { LAYER_KEYWORD_PARAMS } from \"../consts.js\";\nimport { smartEscape } from \"../utils/smartEscape.js\";\nimport TextLayer from \"../legacyLayer/textlayer.js\";\nimport Layer from \"../legacyLayer/layer.js\";\nexport function textStyle(layer) {\n    const keywords = [];\n    let style = \"\";\n    Object.keys(LAYER_KEYWORD_PARAMS).forEach((attr) => {\n        let default_value = LAYER_KEYWORD_PARAMS[attr];\n        let attr_value = layer[attr] || default_value;\n        if (attr_value !== default_value) {\n            keywords.push(attr_value);\n        }\n    });\n    Object.keys(layer).forEach((attr) => {\n        if (attr === \"letter_spacing\" || attr === \"line_spacing\") {\n            keywords.push(`${attr}_${layer[attr]}`);\n        }\n        if (attr === \"font_hinting\") {\n            keywords.push(`${attr.split(\"_\").pop()}_${layer[attr]}`);\n        }\n        if (attr === \"font_antialiasing\") {\n            keywords.push(`antialias_${layer[attr]}`);\n        }\n    });\n    if (layer.hasOwnProperty(\"font_size\" || \"font_family\") || !keywords || keywords.length === 0) {\n        if (!layer.font_size)\n            throw `Must supply font_size for text in overlay/underlay`;\n        if (!layer.font_family)\n            throw `Must supply font_family for text in overlay/underlay`;\n        keywords.unshift(layer.font_size);\n        keywords.unshift(layer.font_family);\n        style = keywords.filter((a) => a).join(\"_\");\n    }\n    return style;\n}\nexport function processLayer(layer) {\n    if (layer instanceof TextLayer || layer instanceof Layer) {\n        return layer.toString();\n    }\n    let result = '';\n    if (isObject(layer)) {\n        if (layer.resource_type === \"fetch\" || (layer.url != null)) {\n            result = `fetch:${base64Encode(layer.url)}`;\n        }\n        else {\n            let public_id = layer.public_id;\n            let format = layer.format;\n            let resource_type = layer.resource_type || \"image\";\n            let type = layer.type || \"upload\";\n            let text = layer.text;\n            let style = null;\n            let components = [];\n            const noPublicId = !public_id || public_id.length === 0;\n            if (!noPublicId) {\n                public_id = public_id.replace(new RegExp(\"/\", 'g'), \":\");\n                if (format != null) {\n                    public_id = `${public_id}.${format}`;\n                }\n            }\n            if ((!text || text.length === 0) && resource_type !== \"text\") {\n                if (noPublicId) {\n                    throw \"Must supply public_id for resource_type layer_parameter\";\n                }\n                if (resource_type === \"subtitles\") {\n                    style = textStyle(layer);\n                }\n            }\n            else {\n                resource_type = \"text\";\n                type = null;\n                // type is ignored for text layers\n                style = textStyle(layer);\n                if (text && text.length >= 0) {\n                    const noStyle = !style;\n                    if (!(noPublicId || noStyle) || (noPublicId && noStyle)) {\n                        throw \"Must supply either style parameters or a public_id when providing text parameter in a text overlay/underlay\";\n                    }\n                    let re = /\\$\\([a-zA-Z]\\w*\\)/g;\n                    let start = 0;\n                    let textSource = smartEscape(decodeURIComponent(text), /[,\\/]/g);\n                    text = \"\";\n                    for (let res = re.exec(textSource); res; res = re.exec(textSource)) {\n                        text += smartEscape(textSource.slice(start, res.index));\n                        text += res[0];\n                        start = res.index + res[0].length;\n                    }\n                    text += encodeURIComponent(textSource.slice(start));\n                }\n            }\n            if (resource_type !== \"image\") {\n                components.push(resource_type);\n            }\n            if (type !== \"upload\") {\n                components.push(type);\n            }\n            components.push(style);\n            components.push(public_id);\n            components.push(text);\n            result = components.filter((a) => a).join(\":\");\n        }\n    }\n    else if (/^fetch:.+/.test(layer)) {\n        result = `fetch:${base64Encode(layer.substr(6))}`;\n    }\n    else {\n        result = layer;\n    }\n    return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}