{"ast":null,"code":"import Condition from './condition.js';\nimport { CONFIG_PARAMS } from './configuration.js';\nimport { cloneDeep } from '../internal/utils/cloneDeep.js';\nimport { camelCase, contains, difference } from \"./utils/legacyBaseUtil.js\";\nimport { snakeCase } from \"./utils/snakeCase.js\";\nimport Expression from './expression.js';\nimport Layer from './legacyLayer/layer.js';\nimport TextLayer from './legacyLayer/textlayer.js';\nimport SubtitlesLayer from './legacyLayer/subtitleslayer.js';\nimport FetchLayer from './legacyLayer/fetchlayer.js';\nimport { isObject } from \"./utils/isObject.js\";\nimport { isString } from \"../internal/utils/dataStructureUtils.js\";\nimport { isEmpty } from \"./utils/isEmpty.js\";\nimport { isFunction } from \"./utils/isFunction.js\";\nimport { identity, withCamelCaseKeys } from \"./utils/legacyBaseUtil.js\";\n/**\n * A list of keys used by the url() function.\n * @private\n */\n\nexport const URL_KEYS = ['accessibility', 'api_secret', 'auth_token', 'cdn_subdomain', 'cloud_name', 'cname', 'format', 'placeholder', 'private_cdn', 'resource_type', 'secure', 'secure_cdn_subdomain', 'secure_distribution', 'shorten', 'sign_url', 'signature', 'ssl_detected', 'type', 'url_suffix', 'use_root_path', 'version'];\n/**\n * Assign key, value to target, when value is not null.<br>\n *   This function mutates the target!\n * @param {object} target the object to assign the values to\n * @param {object} sources one or more objects to get values from\n * @returns {object} the target after the assignment\n */\n\nfunction assignNotNull(target) {\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n\n  sources.forEach(source => {\n    Object.keys(source).forEach(key => {\n      // @ts-ignore\n      if (source[key] != null) {\n        // @ts-ignore\n        target[key] = source[key];\n      }\n    });\n  });\n  return target;\n}\n/**\n * Return true if all items in list are strings\n * @function Util.allString\n * @param {Array} list - an array of items\n */\n\n\nconst allStrings = function (list) {\n  return list.length && list.every(isString);\n};\n/**\n * Transformation parameters\n * Depends on 'util', 'transformation'\n */\n\n\nclass Param {\n  /**\n   * Represents a single parameter.\n   * @class Param\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter.\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @ignore\n   */\n  constructor(name, shortName) {\n    let process = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;\n\n    /**\n     * The name of the parameter in snake_case\n     * @member {string} Param#name\n     */\n    this.name = name;\n    /**\n     * The name of the serialized form of the parameter\n     * @member {string} Param#shortName\n     */\n\n    this.shortName = shortName;\n    /**\n     * Manipulate origValue when value is called\n     * @member {function} Param#process\n     */\n\n    this.process = process;\n  }\n  /**\n   * Set a (unprocessed) value for this parameter\n   * @function Param#set\n   * @param {*} origValue - the value of the parameter\n   * @return {Param} self for chaining\n   */\n\n\n  set(origValue) {\n    this.origValue = origValue;\n    return this;\n  }\n  /**\n   * Generate the serialized form of the parameter\n   * @function Param#serialize\n   * @return {string} the serialized form of the parameter\n   */\n\n\n  serialize() {\n    var val, valid;\n    val = this.value();\n    valid = Array.isArray(val) || isObject(val) || isString(val) ? !isEmpty(val) : val != null;\n\n    if (this.shortName != null && valid) {\n      return `${this.shortName}_${val}`;\n    } else {\n      return '';\n    }\n  }\n  /**\n   * Return the processed value of the parameter\n   * @function Param#value\n   */\n\n\n  value() {\n    return this.process(this.origValue);\n  }\n\n  static norm_color(value) {\n    return value != null ? value.replace(/^#/, 'rgb:') : void 0;\n  }\n\n  static build_array(arg) {\n    if (arg == null) {\n      return [];\n    } else if (Array.isArray(arg)) {\n      return arg;\n    } else {\n      return [arg];\n    }\n  }\n  /**\n   * Covert value to video codec string.\n   *\n   * If the parameter is an object,\n   * @param {(string|Object)} param - the video codec as either a String or a Hash\n   * @return {string} the video codec string in the format codec:profile:level\n   * @example\n   * vc_[ :profile : [level]]\n   * or\n   { codec: 'h264', profile: 'basic', level: '3.1' }\n   * @ignore\n   */\n\n\n  static process_video_params(param) {\n    var video;\n\n    switch (param.constructor) {\n      case Object:\n        video = \"\";\n\n        if ('codec' in param) {\n          video = param.codec;\n\n          if ('profile' in param) {\n            video += \":\" + param.profile;\n\n            if ('level' in param) {\n              video += \":\" + param.level;\n            }\n          }\n        }\n\n        return video;\n\n      case String:\n        return param;\n\n      default:\n        return null;\n    }\n  }\n\n}\n\nclass ArrayParam extends Param {\n  /**\n   * A parameter that represents an array.\n   * @param {string} name - The name of the parameter in snake_case.\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class ArrayParam\n   * @extends Param\n   * @ignore\n   */\n  constructor(name, shortName) {\n    let sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';\n    let process = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    super(name, shortName, process);\n    this.sep = sep;\n  }\n\n  serialize() {\n    if (this.shortName != null) {\n      let arrayValue = this.value();\n\n      if (isEmpty(arrayValue)) {\n        return '';\n      } else if (isString(arrayValue)) {\n        return `${this.shortName}_${arrayValue}`;\n      } else {\n        let flat = arrayValue.map(t => isFunction(t.serialize) ? t.serialize() : t).join(this.sep);\n        return `${this.shortName}_${flat}`;\n      }\n    } else {\n      return '';\n    }\n  }\n\n  value() {\n    if (Array.isArray(this.origValue)) {\n      return this.origValue.map(v => this.process(v));\n    } else {\n      return this.process(this.origValue);\n    }\n  }\n\n  set(origValue) {\n    if (origValue == null || Array.isArray(origValue)) {\n      return super.set(origValue);\n    } else {\n      return super.set([origValue]);\n    }\n  }\n\n}\n\nclass TransformationParam extends Param {\n  /**\n   * A parameter that represents a transformation\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} [shortName='t'] - The name of the serialized form of the parameter\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class TransformationParam\n   * @extends Param\n   * @ignore\n   */\n  constructor(name) {\n    let shortName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"t\";\n    let sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';\n    let process = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    super(name, shortName, process);\n    this.sep = sep;\n  }\n  /**\n   * Generate string representations of the transformation.\n   * @returns {*} Returns either the transformation as a string, or an array of string representations.\n   */\n\n\n  serialize() {\n    let result = '';\n    const val = this.value();\n\n    if (isEmpty(val)) {\n      return result;\n    } // val is an array of strings so join them\n\n\n    if (allStrings(val)) {\n      const joined = val.join(this.sep); // creates t1.t2.t3 in case multiple named transformations were configured\n\n      if (!isEmpty(joined)) {\n        // in case options.transformation was not set with an empty string (val != ['']);\n        result = `${this.shortName}_${joined}`;\n      }\n    } else {\n      // Convert val to an array of strings\n      result = val.map(t => {\n        if (isString(t) && !isEmpty(t)) {\n          return `${this.shortName}_${t}`;\n        }\n\n        if (isFunction(t.serialize)) {\n          return t.serialize();\n        }\n\n        if (isObject(t) && !isEmpty(t)) {\n          return new Transformation(t).serialize();\n        }\n\n        return undefined;\n      }).filter(t => t);\n    }\n\n    return result;\n  }\n\n  set(origValue1) {\n    this.origValue = origValue1;\n\n    if (Array.isArray(this.origValue)) {\n      return super.set(this.origValue);\n    } else {\n      return super.set([this.origValue]);\n    }\n  }\n\n}\n\nconst number_pattern = \"([0-9]*)\\\\.([0-9]+)|([0-9]+)\";\nconst offset_any_pattern = \"(\" + number_pattern + \")([%pP])?\";\n\nclass RangeParam extends Param {\n  /**\n   * A parameter that represents a range\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=norm_range_value ] - Manipulate origValue when value is called\n   * @class RangeParam\n   * @extends Param\n   * @ignore\n   */\n  constructor(name, shortName) {\n    let process = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : RangeParam.norm_range_value;\n    super(name, shortName, process);\n  }\n\n  static norm_range_value(value) {\n    let offset = String(value).match(new RegExp('^' + offset_any_pattern + '$'));\n\n    if (offset) {\n      let modifier = offset[5] != null ? 'p' : '';\n      value = (offset[1] || offset[4]) + modifier;\n    }\n\n    return value;\n  }\n\n}\n\nclass RawParam extends Param {\n  constructor(name, shortName) {\n    let process = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;\n    super(name, shortName, process);\n  }\n\n  serialize() {\n    return this.value();\n  }\n\n}\n\nclass LayerParam extends Param {\n  // Parse layer options\n  // @return [string] layer transformation string\n  // @private\n  value() {\n    if (this.origValue == null) {\n      return '';\n    }\n\n    let result;\n\n    if (this.origValue instanceof Layer) {\n      result = this.origValue;\n    } else if (isObject(this.origValue)) {\n      let layerOptions = withCamelCaseKeys(this.origValue); // @ts-ignore\n\n      if (layerOptions.resourceType === \"text\" || layerOptions.text != null) {\n        result = new TextLayer(layerOptions);\n      } else {\n        // @ts-ignore\n        if (layerOptions.resourceType === \"subtitles\") {\n          result = new SubtitlesLayer(layerOptions);\n        } else {\n          // @ts-ignore\n          if (layerOptions.resourceType === \"fetch\" || layerOptions.url != null) {\n            result = new FetchLayer(layerOptions);\n          } else {\n            result = new Layer(layerOptions);\n          }\n        }\n      }\n    } else if (isString(this.origValue)) {\n      if (/^fetch:.+/.test(this.origValue)) {\n        result = new FetchLayer(this.origValue.substr(6));\n      } else {\n        result = this.origValue;\n      }\n    } else {\n      result = '';\n    }\n\n    return result.toString();\n  }\n\n  static textStyle(layer) {\n    return new TextLayer(layer).textStyleIdentifier();\n  }\n\n}\n/**\n * TransformationBase\n * Depends on 'configuration', 'parameters','util'\n * @internal\n */\n\n\nclass TransformationBase {\n  /**\n   * The base class for transformations.\n   * Members of this class are documented as belonging to the {@link Transformation} class for convenience.\n   * @class TransformationBase\n   */\n  constructor(options) {\n    /** @private */\n\n    /** @private */\n    let parent;\n    let trans;\n    parent = void 0;\n    trans = {};\n    /**\n     * Return an options object that can be used to create an identical Transformation\n     * @function Transformation#toOptions\n     * @return {Object} Returns a plain object representing this transformation\n     */\n\n    this.toOptions = withChain => {\n      let opt = {};\n\n      if (withChain == null) {\n        withChain = true;\n      } // @ts-ignore\n\n\n      Object.keys(trans).forEach(key => opt[key] = trans[key].origValue);\n      assignNotNull(opt, this.otherOptions);\n\n      if (withChain && !isEmpty(this.chained)) {\n        let list = this.chained.map(tr => tr.toOptions());\n        list.push(opt);\n        opt = {};\n        assignNotNull(opt, this.otherOptions); // @ts-ignore\n\n        opt.transformation = list;\n      }\n\n      return opt;\n    };\n    /**\n     * Set a parent for this object for chaining purposes.\n     *\n     * @function Transformation#setParent\n     * @param {Object} object - the parent to be assigned to\n     * @returns {Transformation} Returns this instance for chaining purposes.\n     */\n\n\n    this.setParent = object => {\n      parent = object;\n\n      if (object != null) {\n        // @ts-ignore\n        this.fromOptions(typeof object.toOptions === \"function\" ? object.toOptions() : void 0);\n      }\n\n      return this;\n    };\n    /**\n     * Returns the parent of this object in the chain\n     * @function Transformation#getParent\n     * @protected\n     * @return {Object} Returns the parent of this object if there is any\n     */\n\n\n    this.getParent = () => {\n      return parent;\n    }; // Helper methods to create parameter methods\n    // These methods are defined here because they access `trans` which is\n    // a private member of `TransformationBase`\n\n    /** @protected */\n\n\n    this.param = (value, name, abbr, defaultValue, process) => {\n      if (process == null) {\n        if (isFunction(defaultValue)) {\n          process = defaultValue;\n        } else {\n          process = identity;\n        }\n      } // @ts-ignore\n\n\n      trans[name] = new Param(name, abbr, process).set(value);\n      return this;\n    };\n    /** @protected */\n\n\n    this.rawParam = function (value, name, abbr, defaultValue, process) {\n      process = lastArgCallback(arguments); // @ts-ignore\n\n      trans[name] = new RawParam(name, abbr, process).set(value);\n      return this;\n    };\n    /** @protected */\n\n\n    this.rangeParam = function (value, name, abbr, defaultValue, process) {\n      process = lastArgCallback(arguments); // @ts-ignore\n\n      trans[name] = new RangeParam(name, abbr, process).set(value);\n      return this;\n    };\n    /** @protected */\n\n\n    this.arrayParam = function (value, name, abbr) {\n      let sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \":\";\n      let defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n      let process = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n      process = lastArgCallback(arguments); // @ts-ignore\n\n      trans[name] = new ArrayParam(name, abbr, sep, process).set(value);\n      return this;\n    };\n    /** @protected */\n\n\n    this.transformationParam = function (value, name, abbr) {\n      let sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \".\";\n      let defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n      let process = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n      process = lastArgCallback(arguments); // @ts-ignore\n\n      trans[name] = new TransformationParam(name, abbr, sep, process).set(value);\n      return this;\n    };\n\n    this.layerParam = function (value, name, abbr) {\n      // @ts-ignore\n      trans[name] = new LayerParam(name, abbr).set(value);\n      return this;\n    }; // End Helper methods\n\n    /**\n     * Get the value associated with the given name.\n     * Get the value associated with the given name.\n     * @function Transformation#getValue\n     * @param {string} name - the name of the parameter\n     * @return {*} the processed value associated with the given name\n     * @description Use {@link get}.origValue for the value originally provided for the parameter\n     */\n\n\n    this.getValue = function (name) {\n      // @ts-ignore\n      let value = trans[name] && trans[name].value();\n      return value != null ? value : this.otherOptions[name];\n    };\n    /**\n     * Get the parameter object for the given parameter name\n     * @function Transformation#get\n     * @param {string} name the name of the transformation parameter\n     * @returns {Param} the param object for the given name, or undefined\n     */\n\n\n    this.get = function (name) {\n      // @ts-ignore\n      return trans[name];\n    };\n    /**\n     * Remove a transformation option from the transformation.\n     * @function Transformation#remove\n     * @param {string} name - the name of the option to remove\n     * @return {*} Returns the option that was removed or null if no option by that name was found. The type of the\n     *              returned value depends on the value.\n     */\n\n\n    this.remove = function (name) {\n      var temp;\n\n      switch (false) {\n        // @ts-ignore\n        case trans[name] == null:\n          // @ts-ignore\n          temp = trans[name]; // @ts-ignore\n\n          delete trans[name];\n          return temp.origValue;\n\n        case this.otherOptions[name] == null:\n          temp = this.otherOptions[name];\n          delete this.otherOptions[name];\n          return temp;\n\n        default:\n          return null;\n      }\n    };\n    /**\n     * Return an array of all the keys (option names) in the transformation.\n     * @return {Array<string>} the keys in snakeCase format\n     */\n\n\n    this.keys = function () {\n      var key;\n      return function () {\n        var results;\n        results = [];\n\n        for (key in trans) {\n          if (key != null) {\n            results.push(key.match(VAR_NAME_RE) ? key : snakeCase(key));\n          }\n        }\n\n        return results;\n      }().sort();\n    };\n    /**\n     * Returns a plain object representation of the transformation. Values are processed.\n     * @function Transformation#toPlainObject\n     * @return {Object} the transformation options as plain object\n     */\n\n\n    this.toPlainObject = function () {\n      var hash, key, list;\n      hash = {};\n\n      for (key in trans) {\n        // @ts-ignore\n        hash[key] = trans[key].value(); // @ts-ignore\n\n        if (isObject(hash[key])) {\n          // @ts-ignore\n          hash[key] = cloneDeep(hash[key]);\n        }\n      }\n\n      if (!isEmpty(this.chained)) {\n        list = this.chained.map(tr => tr.toPlainObject());\n        list.push(hash);\n        hash = {\n          transformation: list\n        };\n      }\n\n      return hash;\n    };\n    /**\n     * Complete the current transformation and chain to a new one.\n     * In the URL, transformations are chained together by slashes.\n     * @function Transformation#chain\n     * @return {Transformation} Returns this transformation for chaining\n     * @example\n     * var tr = cloudinary.Transformation.new();\n     * tr.width(10).crop('fit').chain().angle(15).serialize()\n     * // produces \"c_fit,w_10/a_15\"\n     */\n\n\n    this.chain = function () {\n      var names, tr;\n      names = Object.getOwnPropertyNames(trans);\n\n      if (names.length !== 0) {\n        tr = new this.constructor(this.toOptions(false));\n        this.resetTransformations();\n        this.chained.push(tr);\n      }\n\n      return this;\n    };\n\n    this.resetTransformations = function () {\n      trans = {};\n      return this;\n    };\n\n    this.otherOptions = {};\n    this.chained = [];\n    this.fromOptions(options);\n  }\n  /**\n   * Merge the provided options with own's options\n   * @param {Object} [options={}] key-value list of options\n   * @returns {Transformation} Returns this instance for chaining\n   */\n\n\n  fromOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (options instanceof TransformationBase) {\n      this.fromTransformation(options);\n    } else {\n      if (isString(options) || Array.isArray(options)) {\n        options = {\n          transformation: options\n        };\n      }\n\n      options = cloneDeep(options); // Handling of \"if\" statements precedes other options as it creates a chained transformation\n      // @ts-ignore\n\n      if (options[\"if\"]) {\n        // @ts-ignore\n        this.set(\"if\", options[\"if\"]); // @ts-ignore\n\n        delete options[\"if\"];\n      }\n\n      for (let key in options) {\n        // @ts-ignore\n        let opt = options[key];\n\n        if (opt != null) {\n          if (key.match(VAR_NAME_RE)) {\n            if (key !== '$attr') {\n              this.set('variable', key, opt);\n            }\n          } else {\n            this.set(key, opt);\n          }\n        }\n      }\n    }\n\n    return this;\n  }\n\n  fromTransformation(other) {\n    if (other instanceof TransformationBase) {\n      other.keys().forEach(key => this.set(key, other.get(key).origValue));\n    }\n\n    return this;\n  }\n  /**\n   * Set a parameter.\n   * The parameter name `key` is converted to\n   * @param {string} key - the name of the parameter\n   * @param {*} values - the value of the parameter\n   * @returns {Transformation} Returns this instance for chaining\n   */\n\n\n  set(key) {\n    let camelKey;\n    camelKey = camelCase(key);\n\n    for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      values[_key2 - 1] = arguments[_key2];\n    }\n\n    if (contains(methods, camelKey)) {\n      // @ts-ignore\n      this[camelKey].apply(this, values);\n    } else {\n      this.otherOptions[key] = values[0];\n    }\n\n    return this;\n  }\n\n  hasLayer() {\n    return this.getValue(\"overlay\") || this.getValue(\"underlay\");\n  }\n  /**\n   * Generate a string representation of the transformation.\n   * @function Transformation#serialize\n   * @return {string} Returns the transformation as a string\n   */\n\n\n  serialize() {\n    var ifParam, j, len, paramList, ref, ref1, ref2, ref3, ref4, resultArray, t, transformationList, transformationString, transformations, value, variables, vars;\n    resultArray = this.chained.map(tr => tr.serialize());\n    paramList = this.keys();\n    transformations = (ref = this.get(\"transformation\")) != null ? ref.serialize() : void 0;\n    ifParam = (ref1 = this.get(\"if\")) != null ? ref1.serialize() : void 0;\n    variables = processVar((ref2 = this.get(\"variables\")) != null ? ref2.value() : void 0);\n    paramList = difference(paramList, [\"transformation\", \"if\", \"variables\"]);\n    vars = [];\n    transformationList = [];\n\n    for (j = 0, len = paramList.length; j < len; j++) {\n      t = paramList[j];\n\n      if (t.match(VAR_NAME_RE)) {\n        vars.push(t + \"_\" + Expression.normalize((ref3 = this.get(t)) != null ? ref3.value() : void 0));\n      } else {\n        transformationList.push((ref4 = this.get(t)) != null ? ref4.serialize() : void 0);\n      }\n    }\n\n    switch (false) {\n      case !isString(transformations):\n        transformationList.push(transformations);\n        break;\n\n      case !Array.isArray(transformations):\n        resultArray = resultArray.concat(transformations);\n    }\n\n    transformationList = function () {\n      var k, len1, results;\n      results = [];\n\n      for (k = 0, len1 = transformationList.length; k < len1; k++) {\n        value = transformationList[k];\n\n        if (Array.isArray(value) && !isEmpty(value) || !Array.isArray(value) && value) {\n          results.push(value);\n        }\n      }\n\n      return results;\n    }();\n\n    transformationList = vars.sort().concat(variables).concat(transformationList.sort());\n\n    if (ifParam === \"if_end\") {\n      transformationList.push(ifParam);\n    } else if (!isEmpty(ifParam)) {\n      transformationList.unshift(ifParam);\n    }\n\n    transformationString = transformationList.filter(x => !!x).join(param_separator);\n\n    if (!isEmpty(transformationString)) {\n      resultArray.push(transformationString);\n    }\n\n    return resultArray.filter(x => !!x).join(trans_separator);\n  }\n  /**\n   * Provide a list of all the valid transformation option names\n   * @function Transformation#listNames\n   * @private\n   * @return {Array<string>} a array of all the valid option names\n   */\n\n\n  static listNames() {\n    return methods;\n  }\n  /**\n   * Returns the attributes for an HTML tag.\n   * @function Cloudinary.toHtmlAttributes\n   * @return PlainObject\n   */\n\n\n  toHtmlAttributes() {\n    let attrName, height, options, ref2, ref3, value, width;\n    options = {};\n    let snakeCaseKey;\n    Object.keys(this.otherOptions).forEach(key => {\n      value = this.otherOptions[key];\n      snakeCaseKey = snakeCase(key);\n\n      if (!contains(PARAM_NAMES, snakeCaseKey) && !contains(URL_KEYS, snakeCaseKey)) {\n        attrName = /^html_/.test(key) ? key.slice(5) : key;\n        options[attrName] = value;\n      }\n    }); // convert all \"html_key\" to \"key\" with the same value\n\n    this.keys().forEach(key => {\n      if (/^html_/.test(key)) {\n        options[camelCase(key.slice(5))] = this.getValue(key);\n      }\n    });\n\n    if (!(this.hasLayer() || this.getValue(\"angle\") || contains([\"fit\", \"limit\", \"lfill\"], this.getValue(\"crop\")))) {\n      width = (ref2 = this.get(\"width\")) != null ? ref2.origValue : void 0;\n      height = (ref3 = this.get(\"height\")) != null ? ref3.origValue : void 0;\n\n      if (parseFloat(width) >= 1.0) {\n        if (options.width == null) {\n          options.width = width;\n        }\n      }\n\n      if (parseFloat(height) >= 1.0) {\n        if (options.height == null) {\n          options.height = height;\n        }\n      }\n    }\n\n    return options;\n  }\n\n  static isValidParamName(name) {\n    return methods.indexOf(camelCase(name)) >= 0;\n  }\n  /**\n   * Delegate to the parent (up the call chain) to produce HTML\n   * @function Transformation#toHtml\n   * @return {string} HTML representation of the parent if possible.\n   * @example\n   * tag = cloudinary.ImageTag.new(\"sample\", {cloud_name: \"demo\"})\n   * // ImageTag {name: \"img\", publicId: \"sample\"}\n   * tag.toHtml()\n   * // <img src=\"http://res.cloudinary.com/demo/image/upload/sample\">\n   * tag.transformation().crop(\"fit\").width(300).toHtml()\n   * // <img src=\"http://res.cloudinary.com/demo/image/upload/c_fit,w_300/sample\">\n   */\n\n\n  toHtml() {\n    var ref;\n    return (ref = this.getParent()) != null ? typeof ref.toHtml === \"function\" ? ref.toHtml() : void 0 : void 0;\n  }\n\n  toString() {\n    return this.serialize();\n  }\n\n  clone() {\n    return new TransformationBase(this.toOptions(true));\n  }\n\n}\n\nconst VAR_NAME_RE = /^\\$[a-zA-Z0-9]+$/;\nconst trans_separator = '/';\nconst param_separator = ',';\n\nfunction lastArgCallback(args) {\n  var callback;\n  callback = args != null ? args[args.length - 1] : void 0;\n\n  if (isFunction(callback)) {\n    return callback;\n  } else {\n    return void 0;\n  }\n}\n\nfunction processVar(varArray) {\n  var j, len, name, results, v;\n\n  if (Array.isArray(varArray)) {\n    results = [];\n\n    for (j = 0, len = varArray.length; j < len; j++) {\n      [name, v] = varArray[j];\n      results.push(`${name}_${Expression.normalize(v)}`);\n    }\n\n    return results;\n  } else {\n    return varArray;\n  }\n} // @ts-ignore\n\n\nfunction processCustomFunction(_ref) {\n  let {\n    function_type,\n    source\n  } = _ref;\n\n  if (function_type === 'remote') {\n    return [function_type, btoa(source)].join(\":\");\n  } else if (function_type === 'wasm') {\n    return [function_type, source].join(\":\");\n  }\n}\n/**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n * @const Transformation.methods\n * @private\n * @ignore\n * @type {Array<string>}\n */\n\n/**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n * @const {Array<string>} Transformation.PARAM_NAMES\n * @private\n * @ignore\n * @see toHtmlAttributes\n */\n\n\nclass Transformation extends TransformationBase {\n  /**\n   * Represents a single transformation.\n   * @class Transformation\n   * @example\n   * t = new cloudinary.Transformation();\n   * t.angle(20).crop(\"scale\").width(\"auto\");\n   *\n   * // or\n   *\n   * t = new cloudinary.Transformation( {angle: 20, crop: \"scale\", width: \"auto\"});\n   * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\"\n   *  target=\"_blank\">Available image transformations</a>\n   * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\"\n   *  target=\"_blank\">Available video transformations</a>\n   */\n  constructor(options) {\n    super(options);\n  }\n  /**\n   * Convenience constructor\n   * @param {Object} options\n   * @return {Transformation}\n   * @example cl = cloudinary.Transformation.new( {angle: 20, crop: \"scale\", width: \"auto\"})\n   */\n\n\n  static new(options) {\n    return new Transformation(options);\n  }\n  /*\n    Transformation Parameters\n  */\n\n\n  angle(value) {\n    this.arrayParam(value, \"angle\", \"a\", \".\", Expression.normalize);\n    return this;\n  }\n\n  audioCodec(value) {\n    this.param(value, \"audio_codec\", \"ac\");\n    return this;\n  }\n\n  audioFrequency(value) {\n    this.param(value, \"audio_frequency\", \"af\");\n    return this;\n  }\n\n  aspectRatio(value) {\n    this.param(value, \"aspect_ratio\", \"ar\", Expression.normalize);\n    return this;\n  }\n\n  background(value) {\n    this.param(value, \"background\", \"b\", Param.norm_color);\n    return this;\n  }\n\n  bitRate(value) {\n    this.param(value, \"bit_rate\", \"br\");\n    return this;\n  }\n\n  border(value) {\n    return this.param(value, \"border\", \"bo\", border => {\n      if (isObject(border)) {\n        border = Object.assign({}, {\n          color: \"black\",\n          width: 2\n        }, border);\n        return `${border.width}px_solid_${Param.norm_color(border.color)}`;\n      } else {\n        return border;\n      }\n    });\n  }\n\n  color(value) {\n    this.param(value, \"color\", \"co\", Param.norm_color);\n    return this;\n  }\n\n  colorSpace(value) {\n    this.param(value, \"color_space\", \"cs\");\n    return this;\n  }\n\n  crop(value) {\n    this.param(value, \"crop\", \"c\");\n    return this;\n  }\n\n  customFunction(value) {\n    return this.param(value, \"custom_function\", \"fn\", () => {\n      return processCustomFunction(value);\n    });\n  }\n\n  customPreFunction(value) {\n    if (this.get('custom_function')) {\n      return;\n    }\n\n    return this.rawParam(value, \"custom_function\", \"\", () => {\n      value = processCustomFunction(value);\n      return value ? `fn_pre:${value}` : value;\n    });\n  }\n\n  defaultImage(value) {\n    this.param(value, \"default_image\", \"d\");\n    return this;\n  }\n\n  delay(value) {\n    this.param(value, \"delay\", \"dl\");\n    return this;\n  }\n\n  density(value) {\n    this.param(value, \"density\", \"dn\");\n    return this;\n  }\n\n  duration(value) {\n    this.rangeParam(value, \"duration\", \"du\");\n    return this;\n  }\n\n  dpr(value) {\n    return this.param(value, \"dpr\", \"dpr\", dpr => {\n      dpr = dpr.toString();\n\n      if (dpr != null ? dpr.match(/^\\d+$/) : void 0) {\n        return dpr + \".0\";\n      } else {\n        return Expression.normalize(dpr);\n      }\n    });\n  }\n\n  effect(value) {\n    this.arrayParam(value, \"effect\", \"e\", \":\", Expression.normalize);\n    return this;\n  }\n\n  else() {\n    return this.if('else');\n  }\n\n  endIf() {\n    return this.if('end');\n  }\n\n  endOffset(value) {\n    this.rangeParam(value, \"end_offset\", \"eo\");\n    return this;\n  }\n\n  fallbackContent(value) {\n    this.param(value, \"fallback_content\");\n    return this;\n  }\n\n  fetchFormat(value) {\n    this.param(value, \"fetch_format\", \"f\");\n    return this;\n  }\n\n  format(value) {\n    this.param(value, \"format\");\n    return this;\n  }\n\n  flags(value) {\n    this.arrayParam(value, \"flags\", \"fl\", \".\");\n    return this;\n  }\n\n  gravity(value) {\n    this.param(value, \"gravity\", \"g\");\n    return this;\n  }\n\n  fps(value) {\n    return this.param(value, \"fps\", \"fps\", fps => {\n      if (isString(fps)) {\n        return fps;\n      } else if (Array.isArray(fps)) {\n        return fps.join(\"-\");\n      } else {\n        return fps;\n      }\n    });\n  }\n\n  height(value) {\n    return this.param(value, \"height\", \"h\", () => {\n      if (this.getValue(\"crop\") || this.getValue(\"overlay\") || this.getValue(\"underlay\")) {\n        return Expression.normalize(value);\n      } else {\n        return null;\n      }\n    });\n  }\n\n  htmlHeight(value) {\n    this.param(value, \"html_height\");\n    return this;\n  }\n\n  htmlWidth(value) {\n    this.param(value, \"html_width\");\n    return this;\n  }\n\n  if() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var i, ifVal, j, ref, trIf, trRest;\n\n    switch (value) {\n      case \"else\":\n        this.chain();\n        return this.param(value, \"if\", \"if\");\n\n      case \"end\":\n        this.chain();\n\n        for (i = j = ref = this.chained.length - 1; j >= 0; i = j += -1) {\n          ifVal = this.chained[i].getValue(\"if\");\n\n          if (ifVal === \"end\") {\n            break;\n          } else if (ifVal != null) {\n            trIf = Transformation.new().if(ifVal);\n            this.chained[i].remove(\"if\");\n            trRest = this.chained[i];\n            this.chained[i] = Transformation.new().transformation([trIf, trRest]);\n\n            if (ifVal !== \"else\") {\n              break;\n            }\n          }\n        }\n\n        return this.param(value, \"if\", \"if\");\n\n      case \"\":\n        return Condition.new().setParent(this);\n\n      default:\n        return this.param(value, \"if\", \"if\", value => {\n          return Condition.new(value).toString();\n        });\n    }\n  }\n\n  keyframeInterval(value) {\n    this.param(value, \"keyframe_interval\", \"ki\");\n    return this;\n  }\n\n  ocr(value) {\n    this.param(value, \"ocr\", \"ocr\");\n    return this;\n  }\n\n  offset(value) {\n    var end_o, start_o;\n    [start_o, end_o] = isFunction(value != null ? value.split : void 0) ? value.split('..') : Array.isArray(value) ? value : [null, null];\n\n    if (start_o != null) {\n      this.startOffset(start_o);\n    }\n\n    if (end_o != null) {\n      return this.endOffset(end_o);\n    }\n  }\n\n  opacity(value) {\n    this.param(value, \"opacity\", \"o\", Expression.normalize);\n    return this;\n  }\n\n  overlay(value) {\n    this.layerParam(value, \"overlay\", \"l\");\n    return this;\n  }\n\n  page(value) {\n    this.param(value, \"page\", \"pg\");\n    return this;\n  }\n\n  poster(value) {\n    this.param(value, \"poster\");\n    return this;\n  }\n\n  prefix(value) {\n    this.param(value, \"prefix\", \"p\");\n    return this;\n  }\n\n  quality(value) {\n    this.param(value, \"quality\", \"q\", Expression.normalize);\n    return this;\n  }\n\n  radius(value) {\n    this.arrayParam(value, \"radius\", \"r\", \":\", Expression.normalize);\n    return this;\n  }\n\n  rawTransformation(value) {\n    this.rawParam(value, \"raw_transformation\");\n    return this;\n  }\n\n  size(value) {\n    let height, width;\n\n    if (isFunction(value != null ? value.split : void 0)) {\n      [width, height] = value.split('x');\n      this.width(width);\n      return this.height(height);\n    }\n  }\n\n  sourceTypes(value) {\n    this.param(value, \"source_types\");\n    return this;\n  }\n\n  sourceTransformation(value) {\n    return this.param(value, \"source_transformation\");\n  }\n\n  startOffset(value) {\n    this.rangeParam(value, \"start_offset\", \"so\");\n    return this;\n  }\n\n  streamingProfile(value) {\n    this.param(value, \"streaming_profile\", \"sp\");\n    return this;\n  }\n\n  transformation(value) {\n    this.transformationParam(value, \"transformation\", \"t\");\n    return this;\n  }\n\n  underlay(value) {\n    this.layerParam(value, \"underlay\", \"u\");\n    return this;\n  }\n\n  variable(name, value) {\n    this.param(value, name, name);\n    return this;\n  }\n\n  variables(values) {\n    this.arrayParam(values, \"variables\");\n    return this;\n  }\n\n  videoCodec(value) {\n    this.param(value, \"video_codec\", \"vc\", Param.process_video_params);\n    return this;\n  }\n\n  videoSampling(value) {\n    this.param(value, \"video_sampling\", \"vs\");\n    return this;\n  }\n\n  width(value) {\n    this.param(value, \"width\", \"w\", () => {\n      if (this.getValue(\"crop\") || this.getValue(\"overlay\") || this.getValue(\"underlay\")) {\n        return Expression.normalize(value);\n      } else {\n        return null;\n      }\n    });\n    return this;\n  }\n\n  x(value) {\n    this.param(value, \"x\", \"x\", Expression.normalize);\n    return this;\n  }\n\n  y(value) {\n    this.param(value, \"y\", \"y\", Expression.normalize);\n    return this;\n  }\n\n  zoom(value) {\n    this.param(value, \"zoom\", \"z\", Expression.normalize);\n    return this;\n  }\n\n}\n/**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n */\n\n\nconst methods = [\"angle\", \"audioCodec\", \"audioFrequency\", \"aspectRatio\", \"background\", \"bitRate\", \"border\", \"color\", \"colorSpace\", \"crop\", \"customFunction\", \"customPreFunction\", \"defaultImage\", \"delay\", \"density\", \"duration\", \"dpr\", \"effect\", \"else\", \"endIf\", \"endOffset\", \"fallbackContent\", \"fetchFormat\", \"format\", \"flags\", \"gravity\", \"fps\", \"height\", \"htmlHeight\", \"htmlWidth\", \"if\", \"keyframeInterval\", \"ocr\", \"offset\", \"opacity\", \"overlay\", \"page\", \"poster\", \"prefix\", \"quality\", \"radius\", \"rawTransformation\", \"size\", \"sourceTypes\", \"sourceTransformation\", \"startOffset\", \"streamingProfile\", \"transformation\", \"underlay\", \"variable\", \"variables\", \"videoCodec\", \"videoSampling\", \"width\", \"x\", \"y\", \"zoom\"];\n/**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n */\n\nconst PARAM_NAMES = methods.map(snakeCase).concat(CONFIG_PARAMS);\nexport default Transformation;","map":{"version":3,"names":["Condition","CONFIG_PARAMS","cloneDeep","camelCase","contains","difference","snakeCase","Expression","Layer","TextLayer","SubtitlesLayer","FetchLayer","isObject","isString","isEmpty","isFunction","identity","withCamelCaseKeys","URL_KEYS","assignNotNull","target","sources","forEach","source","Object","keys","key","allStrings","list","length","every","Param","constructor","name","shortName","process","set","origValue","serialize","val","valid","value","Array","isArray","norm_color","replace","build_array","arg","process_video_params","param","video","codec","profile","level","String","ArrayParam","sep","undefined","arrayValue","flat","map","t","join","v","TransformationParam","result","joined","Transformation","filter","origValue1","number_pattern","offset_any_pattern","RangeParam","norm_range_value","offset","match","RegExp","modifier","RawParam","LayerParam","layerOptions","resourceType","text","url","test","substr","toString","textStyle","layer","textStyleIdentifier","TransformationBase","options","parent","trans","toOptions","withChain","opt","otherOptions","chained","tr","push","transformation","setParent","object","fromOptions","getParent","abbr","defaultValue","rawParam","lastArgCallback","arguments","rangeParam","arrayParam","transformationParam","layerParam","getValue","get","remove","temp","results","VAR_NAME_RE","sort","toPlainObject","hash","chain","names","getOwnPropertyNames","resetTransformations","fromTransformation","other","camelKey","values","methods","apply","hasLayer","ifParam","j","len","paramList","ref","ref1","ref2","ref3","ref4","resultArray","transformationList","transformationString","transformations","variables","vars","processVar","normalize","concat","k","len1","unshift","x","param_separator","trans_separator","listNames","toHtmlAttributes","attrName","height","width","snakeCaseKey","PARAM_NAMES","slice","parseFloat","isValidParamName","indexOf","toHtml","clone","args","callback","varArray","processCustomFunction","function_type","btoa","new","angle","audioCodec","audioFrequency","aspectRatio","background","bitRate","border","assign","color","colorSpace","crop","customFunction","customPreFunction","defaultImage","delay","density","duration","dpr","effect","else","if","endIf","endOffset","fallbackContent","fetchFormat","format","flags","gravity","fps","htmlHeight","htmlWidth","i","ifVal","trIf","trRest","keyframeInterval","ocr","end_o","start_o","split","startOffset","opacity","overlay","page","poster","prefix","quality","radius","rawTransformation","size","sourceTypes","sourceTransformation","streamingProfile","underlay","variable","videoCodec","videoSampling","y","zoom"],"sources":["C:/Users/DELL/OneDrive/Desktop/New folder (2)/New folder/node_modules/@cloudinary/url-gen/backwards/transformation.js"],"sourcesContent":["import Condition from './condition.js';\nimport { CONFIG_PARAMS } from './configuration.js';\nimport { cloneDeep } from '../internal/utils/cloneDeep.js';\nimport { camelCase, contains, difference, } from \"./utils/legacyBaseUtil.js\";\nimport { snakeCase } from \"./utils/snakeCase.js\";\nimport Expression from './expression.js';\nimport Layer from './legacyLayer/layer.js';\nimport TextLayer from './legacyLayer/textlayer.js';\nimport SubtitlesLayer from './legacyLayer/subtitleslayer.js';\nimport FetchLayer from './legacyLayer/fetchlayer.js';\nimport { isObject } from \"./utils/isObject.js\";\nimport { isString } from \"../internal/utils/dataStructureUtils.js\";\nimport { isEmpty } from \"./utils/isEmpty.js\";\nimport { isFunction } from \"./utils/isFunction.js\";\nimport { identity, withCamelCaseKeys } from \"./utils/legacyBaseUtil.js\";\n/**\n * A list of keys used by the url() function.\n * @private\n */\nexport const URL_KEYS = [\n    'accessibility',\n    'api_secret',\n    'auth_token',\n    'cdn_subdomain',\n    'cloud_name',\n    'cname',\n    'format',\n    'placeholder',\n    'private_cdn',\n    'resource_type',\n    'secure',\n    'secure_cdn_subdomain',\n    'secure_distribution',\n    'shorten',\n    'sign_url',\n    'signature',\n    'ssl_detected',\n    'type',\n    'url_suffix',\n    'use_root_path',\n    'version'\n];\n/**\n * Assign key, value to target, when value is not null.<br>\n *   This function mutates the target!\n * @param {object} target the object to assign the values to\n * @param {object} sources one or more objects to get values from\n * @returns {object} the target after the assignment\n */\nfunction assignNotNull(target, ...sources) {\n    sources.forEach(source => {\n        Object.keys(source).forEach(key => {\n            // @ts-ignore\n            if (source[key] != null) {\n                // @ts-ignore\n                target[key] = source[key];\n            }\n        });\n    });\n    return target;\n}\n/**\n * Return true if all items in list are strings\n * @function Util.allString\n * @param {Array} list - an array of items\n */\nconst allStrings = function (list) {\n    return list.length && list.every(isString);\n};\n/**\n * Transformation parameters\n * Depends on 'util', 'transformation'\n */\nclass Param {\n    /**\n     * Represents a single parameter.\n     * @class Param\n     * @param {string} name - The name of the parameter in snake_case\n     * @param {string} shortName - The name of the serialized form of the parameter.\n     *                         If a value is not provided, the parameter will not be serialized.\n     * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n     * @ignore\n     */\n    constructor(name, shortName, process = identity) {\n        /**\n         * The name of the parameter in snake_case\n         * @member {string} Param#name\n         */\n        this.name = name;\n        /**\n         * The name of the serialized form of the parameter\n         * @member {string} Param#shortName\n         */\n        this.shortName = shortName;\n        /**\n         * Manipulate origValue when value is called\n         * @member {function} Param#process\n         */\n        this.process = process;\n    }\n    /**\n     * Set a (unprocessed) value for this parameter\n     * @function Param#set\n     * @param {*} origValue - the value of the parameter\n     * @return {Param} self for chaining\n     */\n    set(origValue) {\n        this.origValue = origValue;\n        return this;\n    }\n    /**\n     * Generate the serialized form of the parameter\n     * @function Param#serialize\n     * @return {string} the serialized form of the parameter\n     */\n    serialize() {\n        var val, valid;\n        val = this.value();\n        valid = Array.isArray(val) || isObject(val) || isString(val) ? !isEmpty(val) : val != null;\n        if ((this.shortName != null) && valid) {\n            return `${this.shortName}_${val}`;\n        }\n        else {\n            return '';\n        }\n    }\n    /**\n     * Return the processed value of the parameter\n     * @function Param#value\n     */\n    value() {\n        return this.process(this.origValue);\n    }\n    static norm_color(value) {\n        return value != null ? value.replace(/^#/, 'rgb:') : void 0;\n    }\n    static build_array(arg) {\n        if (arg == null) {\n            return [];\n        }\n        else if (Array.isArray(arg)) {\n            return arg;\n        }\n        else {\n            return [arg];\n        }\n    }\n    /**\n     * Covert value to video codec string.\n     *\n     * If the parameter is an object,\n     * @param {(string|Object)} param - the video codec as either a String or a Hash\n     * @return {string} the video codec string in the format codec:profile:level\n     * @example\n     * vc_[ :profile : [level]]\n     * or\n     { codec: 'h264', profile: 'basic', level: '3.1' }\n     * @ignore\n     */\n    static process_video_params(param) {\n        var video;\n        switch (param.constructor) {\n            case Object:\n                video = \"\";\n                if ('codec' in param) {\n                    video = param.codec;\n                    if ('profile' in param) {\n                        video += \":\" + param.profile;\n                        if ('level' in param) {\n                            video += \":\" + param.level;\n                        }\n                    }\n                }\n                return video;\n            case String:\n                return param;\n            default:\n                return null;\n        }\n    }\n}\nclass ArrayParam extends Param {\n    /**\n     * A parameter that represents an array.\n     * @param {string} name - The name of the parameter in snake_case.\n     * @param {string} shortName - The name of the serialized form of the parameter\n     *                         If a value is not provided, the parameter will not be serialized.\n     * @param {string} [sep='.'] - The separator to use when joining the array elements together\n     * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n     * @class ArrayParam\n     * @extends Param\n     * @ignore\n     */\n    constructor(name, shortName, sep = '.', process = undefined) {\n        super(name, shortName, process);\n        this.sep = sep;\n    }\n    serialize() {\n        if (this.shortName != null) {\n            let arrayValue = this.value();\n            if (isEmpty(arrayValue)) {\n                return '';\n            }\n            else if (isString(arrayValue)) {\n                return `${this.shortName}_${arrayValue}`;\n            }\n            else {\n                let flat = arrayValue.map((t) => isFunction(t.serialize) ? t.serialize() : t).join(this.sep);\n                return `${this.shortName}_${flat}`;\n            }\n        }\n        else {\n            return '';\n        }\n    }\n    value() {\n        if (Array.isArray(this.origValue)) {\n            return this.origValue.map(v => this.process(v));\n        }\n        else {\n            return this.process(this.origValue);\n        }\n    }\n    set(origValue) {\n        if ((origValue == null) || Array.isArray(origValue)) {\n            return super.set(origValue);\n        }\n        else {\n            return super.set([origValue]);\n        }\n    }\n}\nclass TransformationParam extends Param {\n    /**\n     * A parameter that represents a transformation\n     * @param {string} name - The name of the parameter in snake_case\n     * @param {string} [shortName='t'] - The name of the serialized form of the parameter\n     * @param {string} [sep='.'] - The separator to use when joining the array elements together\n     * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n     * @class TransformationParam\n     * @extends Param\n     * @ignore\n     */\n    constructor(name, shortName = \"t\", sep = '.', process = undefined) {\n        super(name, shortName, process);\n        this.sep = sep;\n    }\n    /**\n     * Generate string representations of the transformation.\n     * @returns {*} Returns either the transformation as a string, or an array of string representations.\n     */\n    serialize() {\n        let result = '';\n        const val = this.value();\n        if (isEmpty(val)) {\n            return result;\n        }\n        // val is an array of strings so join them\n        if (allStrings(val)) {\n            const joined = val.join(this.sep); // creates t1.t2.t3 in case multiple named transformations were configured\n            if (!isEmpty(joined)) {\n                // in case options.transformation was not set with an empty string (val != ['']);\n                result = `${this.shortName}_${joined}`;\n            }\n        }\n        else { // Convert val to an array of strings\n            result = val.map((t) => {\n                if (isString(t) && !isEmpty(t)) {\n                    return `${this.shortName}_${t}`;\n                }\n                if (isFunction(t.serialize)) {\n                    return t.serialize();\n                }\n                if (isObject(t) && !isEmpty(t)) {\n                    return new Transformation(t).serialize();\n                }\n                return undefined;\n            }).filter((t) => t);\n        }\n        return result;\n    }\n    set(origValue1) {\n        this.origValue = origValue1;\n        if (Array.isArray(this.origValue)) {\n            return super.set(this.origValue);\n        }\n        else {\n            return super.set([this.origValue]);\n        }\n    }\n}\nconst number_pattern = \"([0-9]*)\\\\.([0-9]+)|([0-9]+)\";\nconst offset_any_pattern = \"(\" + number_pattern + \")([%pP])?\";\nclass RangeParam extends Param {\n    /**\n     * A parameter that represents a range\n     * @param {string} name - The name of the parameter in snake_case\n     * @param {string} shortName - The name of the serialized form of the parameter\n     *                         If a value is not provided, the parameter will not be serialized.\n     * @param {function} [process=norm_range_value ] - Manipulate origValue when value is called\n     * @class RangeParam\n     * @extends Param\n     * @ignore\n     */\n    constructor(name, shortName, process = RangeParam.norm_range_value) {\n        super(name, shortName, process);\n    }\n    static norm_range_value(value) {\n        let offset = String(value).match(new RegExp('^' + offset_any_pattern + '$'));\n        if (offset) {\n            let modifier = offset[5] != null ? 'p' : '';\n            value = (offset[1] || offset[4]) + modifier;\n        }\n        return value;\n    }\n}\nclass RawParam extends Param {\n    constructor(name, shortName, process = identity) {\n        super(name, shortName, process);\n    }\n    serialize() {\n        return this.value();\n    }\n}\nclass LayerParam extends Param {\n    // Parse layer options\n    // @return [string] layer transformation string\n    // @private\n    value() {\n        if (this.origValue == null) {\n            return '';\n        }\n        let result;\n        if (this.origValue instanceof Layer) {\n            result = this.origValue;\n        }\n        else if (isObject(this.origValue)) {\n            let layerOptions = withCamelCaseKeys(this.origValue);\n            // @ts-ignore\n            if (layerOptions.resourceType === \"text\" || (layerOptions.text != null)) {\n                result = new TextLayer(layerOptions);\n            }\n            else { // @ts-ignore\n                if (layerOptions.resourceType === \"subtitles\") {\n                    result = new SubtitlesLayer(layerOptions);\n                }\n                else { // @ts-ignore\n                    if (layerOptions.resourceType === \"fetch\" || (layerOptions.url != null)) {\n                        result = new FetchLayer(layerOptions);\n                    }\n                    else {\n                        result = new Layer(layerOptions);\n                    }\n                }\n            }\n        }\n        else if (isString(this.origValue)) {\n            if (/^fetch:.+/.test(this.origValue)) {\n                result = new FetchLayer(this.origValue.substr(6));\n            }\n            else {\n                result = this.origValue;\n            }\n        }\n        else {\n            result = '';\n        }\n        return result.toString();\n    }\n    static textStyle(layer) {\n        return (new TextLayer(layer)).textStyleIdentifier();\n    }\n}\n/**\n * TransformationBase\n * Depends on 'configuration', 'parameters','util'\n * @internal\n */\nclass TransformationBase {\n    /**\n     * The base class for transformations.\n     * Members of this class are documented as belonging to the {@link Transformation} class for convenience.\n     * @class TransformationBase\n     */\n    constructor(options) {\n        /** @private */\n        /** @private */\n        let parent;\n        let trans;\n        parent = void 0;\n        trans = {};\n        /**\n         * Return an options object that can be used to create an identical Transformation\n         * @function Transformation#toOptions\n         * @return {Object} Returns a plain object representing this transformation\n         */\n        this.toOptions = (withChain) => {\n            let opt = {};\n            if (withChain == null) {\n                withChain = true;\n            }\n            // @ts-ignore\n            Object.keys(trans).forEach(key => opt[key] = trans[key].origValue);\n            assignNotNull(opt, this.otherOptions);\n            if (withChain && !isEmpty(this.chained)) {\n                let list = this.chained.map((tr) => tr.toOptions());\n                list.push(opt);\n                opt = {};\n                assignNotNull(opt, this.otherOptions);\n                // @ts-ignore\n                opt.transformation = list;\n            }\n            return opt;\n        };\n        /**\n         * Set a parent for this object for chaining purposes.\n         *\n         * @function Transformation#setParent\n         * @param {Object} object - the parent to be assigned to\n         * @returns {Transformation} Returns this instance for chaining purposes.\n         */\n        this.setParent = (object) => {\n            parent = object;\n            if (object != null) {\n                // @ts-ignore\n                this.fromOptions(typeof object.toOptions === \"function\" ? object.toOptions() : void 0);\n            }\n            return this;\n        };\n        /**\n         * Returns the parent of this object in the chain\n         * @function Transformation#getParent\n         * @protected\n         * @return {Object} Returns the parent of this object if there is any\n         */\n        this.getParent = () => {\n            return parent;\n        };\n        // Helper methods to create parameter methods\n        // These methods are defined here because they access `trans` which is\n        // a private member of `TransformationBase`\n        /** @protected */\n        this.param = (value, name, abbr, defaultValue, process) => {\n            if (process == null) {\n                if (isFunction(defaultValue)) {\n                    process = defaultValue;\n                }\n                else {\n                    process = identity;\n                }\n            }\n            // @ts-ignore\n            trans[name] = new Param(name, abbr, process).set(value);\n            return this;\n        };\n        /** @protected */\n        this.rawParam = function (value, name, abbr, defaultValue, process) {\n            process = lastArgCallback(arguments);\n            // @ts-ignore\n            trans[name] = new RawParam(name, abbr, process).set(value);\n            return this;\n        };\n        /** @protected */\n        this.rangeParam = function (value, name, abbr, defaultValue, process) {\n            process = lastArgCallback(arguments);\n            // @ts-ignore\n            trans[name] = new RangeParam(name, abbr, process).set(value);\n            return this;\n        };\n        /** @protected */\n        this.arrayParam = function (value, name, abbr, sep = \":\", defaultValue = [], process = undefined) {\n            process = lastArgCallback(arguments);\n            // @ts-ignore\n            trans[name] = new ArrayParam(name, abbr, sep, process).set(value);\n            return this;\n        };\n        /** @protected */\n        this.transformationParam = function (value, name, abbr, sep = \".\", defaultValue = undefined, process = undefined) {\n            process = lastArgCallback(arguments);\n            // @ts-ignore\n            trans[name] = new TransformationParam(name, abbr, sep, process).set(value);\n            return this;\n        };\n        this.layerParam = function (value, name, abbr) {\n            // @ts-ignore\n            trans[name] = new LayerParam(name, abbr).set(value);\n            return this;\n        };\n        // End Helper methods\n        /**\n         * Get the value associated with the given name.\n         * Get the value associated with the given name.\n         * @function Transformation#getValue\n         * @param {string} name - the name of the parameter\n         * @return {*} the processed value associated with the given name\n         * @description Use {@link get}.origValue for the value originally provided for the parameter\n         */\n        this.getValue = function (name) {\n            // @ts-ignore\n            let value = trans[name] && trans[name].value();\n            return value != null ? value : this.otherOptions[name];\n        };\n        /**\n         * Get the parameter object for the given parameter name\n         * @function Transformation#get\n         * @param {string} name the name of the transformation parameter\n         * @returns {Param} the param object for the given name, or undefined\n         */\n        this.get = function (name) {\n            // @ts-ignore\n            return trans[name];\n        };\n        /**\n         * Remove a transformation option from the transformation.\n         * @function Transformation#remove\n         * @param {string} name - the name of the option to remove\n         * @return {*} Returns the option that was removed or null if no option by that name was found. The type of the\n         *              returned value depends on the value.\n         */\n        this.remove = function (name) {\n            var temp;\n            switch (false) {\n                // @ts-ignore\n                case trans[name] == null:\n                    // @ts-ignore\n                    temp = trans[name];\n                    // @ts-ignore\n                    delete trans[name];\n                    return temp.origValue;\n                case this.otherOptions[name] == null:\n                    temp = this.otherOptions[name];\n                    delete this.otherOptions[name];\n                    return temp;\n                default:\n                    return null;\n            }\n        };\n        /**\n         * Return an array of all the keys (option names) in the transformation.\n         * @return {Array<string>} the keys in snakeCase format\n         */\n        this.keys = function () {\n            var key;\n            return ((function () {\n                var results;\n                results = [];\n                for (key in trans) {\n                    if (key != null) {\n                        results.push(key.match(VAR_NAME_RE) ? key : snakeCase(key));\n                    }\n                }\n                return results;\n            })()).sort();\n        };\n        /**\n         * Returns a plain object representation of the transformation. Values are processed.\n         * @function Transformation#toPlainObject\n         * @return {Object} the transformation options as plain object\n         */\n        this.toPlainObject = function () {\n            var hash, key, list;\n            hash = {};\n            for (key in trans) {\n                // @ts-ignore\n                hash[key] = trans[key].value();\n                // @ts-ignore\n                if (isObject(hash[key])) {\n                    // @ts-ignore\n                    hash[key] = cloneDeep(hash[key]);\n                }\n            }\n            if (!isEmpty(this.chained)) {\n                list = this.chained.map((tr) => tr.toPlainObject());\n                list.push(hash);\n                hash = {\n                    transformation: list\n                };\n            }\n            return hash;\n        };\n        /**\n         * Complete the current transformation and chain to a new one.\n         * In the URL, transformations are chained together by slashes.\n         * @function Transformation#chain\n         * @return {Transformation} Returns this transformation for chaining\n         * @example\n         * var tr = cloudinary.Transformation.new();\n         * tr.width(10).crop('fit').chain().angle(15).serialize()\n         * // produces \"c_fit,w_10/a_15\"\n         */\n        this.chain = function () {\n            var names, tr;\n            names = Object.getOwnPropertyNames(trans);\n            if (names.length !== 0) {\n                tr = new this.constructor(this.toOptions(false));\n                this.resetTransformations();\n                this.chained.push(tr);\n            }\n            return this;\n        };\n        this.resetTransformations = function () {\n            trans = {};\n            return this;\n        };\n        this.otherOptions = {};\n        this.chained = [];\n        this.fromOptions(options);\n    }\n    /**\n     * Merge the provided options with own's options\n     * @param {Object} [options={}] key-value list of options\n     * @returns {Transformation} Returns this instance for chaining\n     */\n    fromOptions(options = {}) {\n        if (options instanceof TransformationBase) {\n            this.fromTransformation(options);\n        }\n        else {\n            if (isString(options) || Array.isArray(options)) {\n                options = {\n                    transformation: options\n                };\n            }\n            options = cloneDeep(options);\n            // Handling of \"if\" statements precedes other options as it creates a chained transformation\n            // @ts-ignore\n            if (options[\"if\"]) {\n                // @ts-ignore\n                this.set(\"if\", options[\"if\"]);\n                // @ts-ignore\n                delete options[\"if\"];\n            }\n            for (let key in options) {\n                // @ts-ignore\n                let opt = options[key];\n                if (opt != null) {\n                    if (key.match(VAR_NAME_RE)) {\n                        if (key !== '$attr') {\n                            this.set('variable', key, opt);\n                        }\n                    }\n                    else {\n                        this.set(key, opt);\n                    }\n                }\n            }\n        }\n        return this;\n    }\n    fromTransformation(other) {\n        if (other instanceof TransformationBase) {\n            other.keys().forEach(key => this.set(key, other.get(key).origValue));\n        }\n        return this;\n    }\n    /**\n     * Set a parameter.\n     * The parameter name `key` is converted to\n     * @param {string} key - the name of the parameter\n     * @param {*} values - the value of the parameter\n     * @returns {Transformation} Returns this instance for chaining\n     */\n    set(key, ...values) {\n        let camelKey;\n        camelKey = camelCase(key);\n        if (contains(methods, camelKey)) {\n            // @ts-ignore\n            this[camelKey].apply(this, values);\n        }\n        else {\n            this.otherOptions[key] = values[0];\n        }\n        return this;\n    }\n    hasLayer() {\n        return this.getValue(\"overlay\") || this.getValue(\"underlay\");\n    }\n    /**\n     * Generate a string representation of the transformation.\n     * @function Transformation#serialize\n     * @return {string} Returns the transformation as a string\n     */\n    serialize() {\n        var ifParam, j, len, paramList, ref, ref1, ref2, ref3, ref4, resultArray, t, transformationList, transformationString, transformations, value, variables, vars;\n        resultArray = this.chained.map((tr) => tr.serialize());\n        paramList = this.keys();\n        transformations = (ref = this.get(\"transformation\")) != null ? ref.serialize() : void 0;\n        ifParam = (ref1 = this.get(\"if\")) != null ? ref1.serialize() : void 0;\n        variables = processVar((ref2 = this.get(\"variables\")) != null ? ref2.value() : void 0);\n        paramList = difference(paramList, [\"transformation\", \"if\", \"variables\"]);\n        vars = [];\n        transformationList = [];\n        for (j = 0, len = paramList.length; j < len; j++) {\n            t = paramList[j];\n            if (t.match(VAR_NAME_RE)) {\n                vars.push(t + \"_\" + Expression.normalize((ref3 = this.get(t)) != null ? ref3.value() : void 0));\n            }\n            else {\n                transformationList.push((ref4 = this.get(t)) != null ? ref4.serialize() : void 0);\n            }\n        }\n        switch (false) {\n            case !isString(transformations):\n                transformationList.push(transformations);\n                break;\n            case !Array.isArray(transformations):\n                resultArray = resultArray.concat(transformations);\n        }\n        transformationList = (function () {\n            var k, len1, results;\n            results = [];\n            for (k = 0, len1 = transformationList.length; k < len1; k++) {\n                value = transformationList[k];\n                if (Array.isArray(value) && !isEmpty(value) || !Array.isArray(value) && value) {\n                    results.push(value);\n                }\n            }\n            return results;\n        })();\n        transformationList = vars.sort().concat(variables).concat(transformationList.sort());\n        if (ifParam === \"if_end\") {\n            transformationList.push(ifParam);\n        }\n        else if (!isEmpty(ifParam)) {\n            transformationList.unshift(ifParam);\n        }\n        transformationString = (transformationList).filter(x => !!x).join(param_separator);\n        if (!isEmpty(transformationString)) {\n            resultArray.push(transformationString);\n        }\n        return (resultArray).filter((x) => !!x).join(trans_separator);\n    }\n    /**\n     * Provide a list of all the valid transformation option names\n     * @function Transformation#listNames\n     * @private\n     * @return {Array<string>} a array of all the valid option names\n     */\n    static listNames() {\n        return methods;\n    }\n    /**\n     * Returns the attributes for an HTML tag.\n     * @function Cloudinary.toHtmlAttributes\n     * @return PlainObject\n     */\n    toHtmlAttributes() {\n        let attrName, height, options, ref2, ref3, value, width;\n        options = {};\n        let snakeCaseKey;\n        Object.keys(this.otherOptions).forEach(key => {\n            value = this.otherOptions[key];\n            snakeCaseKey = snakeCase(key);\n            if (!contains(PARAM_NAMES, snakeCaseKey) && !contains(URL_KEYS, snakeCaseKey)) {\n                attrName = /^html_/.test(key) ? key.slice(5) : key;\n                options[attrName] = value;\n            }\n        });\n        // convert all \"html_key\" to \"key\" with the same value\n        this.keys().forEach(key => {\n            if (/^html_/.test(key)) {\n                options[camelCase(key.slice(5))] = this.getValue(key);\n            }\n        });\n        if (!(this.hasLayer() || this.getValue(\"angle\") || contains([\"fit\", \"limit\", \"lfill\"], this.getValue(\"crop\")))) {\n            width = (ref2 = this.get(\"width\")) != null ? ref2.origValue : void 0;\n            height = (ref3 = this.get(\"height\")) != null ? ref3.origValue : void 0;\n            if (parseFloat(width) >= 1.0) {\n                if (options.width == null) {\n                    options.width = width;\n                }\n            }\n            if (parseFloat(height) >= 1.0) {\n                if (options.height == null) {\n                    options.height = height;\n                }\n            }\n        }\n        return options;\n    }\n    static isValidParamName(name) {\n        return methods.indexOf(camelCase(name)) >= 0;\n    }\n    /**\n     * Delegate to the parent (up the call chain) to produce HTML\n     * @function Transformation#toHtml\n     * @return {string} HTML representation of the parent if possible.\n     * @example\n     * tag = cloudinary.ImageTag.new(\"sample\", {cloud_name: \"demo\"})\n     * // ImageTag {name: \"img\", publicId: \"sample\"}\n     * tag.toHtml()\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/sample\">\n     * tag.transformation().crop(\"fit\").width(300).toHtml()\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/c_fit,w_300/sample\">\n     */\n    toHtml() {\n        var ref;\n        return (ref = this.getParent()) != null ? typeof ref.toHtml === \"function\" ? ref.toHtml() : void 0 : void 0;\n    }\n    toString() {\n        return this.serialize();\n    }\n    clone() {\n        return new TransformationBase(this.toOptions(true));\n    }\n}\nconst VAR_NAME_RE = /^\\$[a-zA-Z0-9]+$/;\nconst trans_separator = '/';\nconst param_separator = ',';\nfunction lastArgCallback(args) {\n    var callback;\n    callback = args != null ? args[args.length - 1] : void 0;\n    if (isFunction(callback)) {\n        return callback;\n    }\n    else {\n        return void 0;\n    }\n}\nfunction processVar(varArray) {\n    var j, len, name, results, v;\n    if (Array.isArray(varArray)) {\n        results = [];\n        for (j = 0, len = varArray.length; j < len; j++) {\n            [name, v] = varArray[j];\n            results.push(`${name}_${Expression.normalize(v)}`);\n        }\n        return results;\n    }\n    else {\n        return varArray;\n    }\n}\n// @ts-ignore\nfunction processCustomFunction({ function_type, source }) {\n    if (function_type === 'remote') {\n        return [function_type, btoa(source)].join(\":\");\n    }\n    else if (function_type === 'wasm') {\n        return [function_type, source].join(\":\");\n    }\n}\n/**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n * @const Transformation.methods\n * @private\n * @ignore\n * @type {Array<string>}\n */\n/**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n * @const {Array<string>} Transformation.PARAM_NAMES\n * @private\n * @ignore\n * @see toHtmlAttributes\n */\nclass Transformation extends TransformationBase {\n    /**\n     * Represents a single transformation.\n     * @class Transformation\n     * @example\n     * t = new cloudinary.Transformation();\n     * t.angle(20).crop(\"scale\").width(\"auto\");\n     *\n     * // or\n     *\n     * t = new cloudinary.Transformation( {angle: 20, crop: \"scale\", width: \"auto\"});\n     * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\"\n     *  target=\"_blank\">Available image transformations</a>\n     * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\"\n     *  target=\"_blank\">Available video transformations</a>\n     */\n    constructor(options) {\n        super(options);\n    }\n    /**\n     * Convenience constructor\n     * @param {Object} options\n     * @return {Transformation}\n     * @example cl = cloudinary.Transformation.new( {angle: 20, crop: \"scale\", width: \"auto\"})\n     */\n    static new(options) {\n        return new Transformation(options);\n    }\n    /*\n      Transformation Parameters\n    */\n    angle(value) {\n        this.arrayParam(value, \"angle\", \"a\", \".\", Expression.normalize);\n        return this;\n    }\n    audioCodec(value) {\n        this.param(value, \"audio_codec\", \"ac\");\n        return this;\n    }\n    audioFrequency(value) {\n        this.param(value, \"audio_frequency\", \"af\");\n        return this;\n    }\n    aspectRatio(value) {\n        this.param(value, \"aspect_ratio\", \"ar\", Expression.normalize);\n        return this;\n    }\n    background(value) {\n        this.param(value, \"background\", \"b\", Param.norm_color);\n        return this;\n    }\n    bitRate(value) {\n        this.param(value, \"bit_rate\", \"br\");\n        return this;\n    }\n    border(value) {\n        return this.param(value, \"border\", \"bo\", (border) => {\n            if (isObject(border)) {\n                border = Object.assign({}, {\n                    color: \"black\",\n                    width: 2\n                }, border);\n                return `${border.width}px_solid_${Param.norm_color(border.color)}`;\n            }\n            else {\n                return border;\n            }\n        });\n    }\n    color(value) {\n        this.param(value, \"color\", \"co\", Param.norm_color);\n        return this;\n    }\n    colorSpace(value) {\n        this.param(value, \"color_space\", \"cs\");\n        return this;\n    }\n    crop(value) {\n        this.param(value, \"crop\", \"c\");\n        return this;\n    }\n    customFunction(value) {\n        return this.param(value, \"custom_function\", \"fn\", () => {\n            return processCustomFunction(value);\n        });\n    }\n    customPreFunction(value) {\n        if (this.get('custom_function')) {\n            return;\n        }\n        return this.rawParam(value, \"custom_function\", \"\", () => {\n            value = processCustomFunction(value);\n            return value ? `fn_pre:${value}` : value;\n        });\n    }\n    defaultImage(value) {\n        this.param(value, \"default_image\", \"d\");\n        return this;\n    }\n    delay(value) {\n        this.param(value, \"delay\", \"dl\");\n        return this;\n    }\n    density(value) {\n        this.param(value, \"density\", \"dn\");\n        return this;\n    }\n    duration(value) {\n        this.rangeParam(value, \"duration\", \"du\");\n        return this;\n    }\n    dpr(value) {\n        return this.param(value, \"dpr\", \"dpr\", (dpr) => {\n            dpr = dpr.toString();\n            if (dpr != null ? dpr.match(/^\\d+$/) : void 0) {\n                return dpr + \".0\";\n            }\n            else {\n                return Expression.normalize(dpr);\n            }\n        });\n    }\n    effect(value) {\n        this.arrayParam(value, \"effect\", \"e\", \":\", Expression.normalize);\n        return this;\n    }\n    else() {\n        return this.if('else');\n    }\n    endIf() {\n        return this.if('end');\n    }\n    endOffset(value) {\n        this.rangeParam(value, \"end_offset\", \"eo\");\n        return this;\n    }\n    fallbackContent(value) {\n        this.param(value, \"fallback_content\");\n        return this;\n    }\n    fetchFormat(value) {\n        this.param(value, \"fetch_format\", \"f\");\n        return this;\n    }\n    format(value) {\n        this.param(value, \"format\");\n        return this;\n    }\n    flags(value) {\n        this.arrayParam(value, \"flags\", \"fl\", \".\");\n        return this;\n    }\n    gravity(value) {\n        this.param(value, \"gravity\", \"g\");\n        return this;\n    }\n    fps(value) {\n        return this.param(value, \"fps\", \"fps\", (fps) => {\n            if (isString(fps)) {\n                return fps;\n            }\n            else if (Array.isArray(fps)) {\n                return fps.join(\"-\");\n            }\n            else {\n                return fps;\n            }\n        });\n    }\n    height(value) {\n        return this.param(value, \"height\", \"h\", () => {\n            if (this.getValue(\"crop\") || this.getValue(\"overlay\") || this.getValue(\"underlay\")) {\n                return Expression.normalize(value);\n            }\n            else {\n                return null;\n            }\n        });\n    }\n    htmlHeight(value) {\n        this.param(value, \"html_height\");\n        return this;\n    }\n    htmlWidth(value) {\n        this.param(value, \"html_width\");\n        return this;\n    }\n    if(value = \"\") {\n        var i, ifVal, j, ref, trIf, trRest;\n        switch (value) {\n            case \"else\":\n                this.chain();\n                return this.param(value, \"if\", \"if\");\n            case \"end\":\n                this.chain();\n                for (i = j = ref = this.chained.length - 1; j >= 0; i = j += -1) {\n                    ifVal = this.chained[i].getValue(\"if\");\n                    if (ifVal === \"end\") {\n                        break;\n                    }\n                    else if (ifVal != null) {\n                        trIf = Transformation.new().if(ifVal);\n                        this.chained[i].remove(\"if\");\n                        trRest = this.chained[i];\n                        this.chained[i] = Transformation.new().transformation([trIf, trRest]);\n                        if (ifVal !== \"else\") {\n                            break;\n                        }\n                    }\n                }\n                return this.param(value, \"if\", \"if\");\n            case \"\":\n                return Condition.new().setParent(this);\n            default:\n                return this.param(value, \"if\", \"if\", (value) => {\n                    return Condition.new(value).toString();\n                });\n        }\n    }\n    keyframeInterval(value) {\n        this.param(value, \"keyframe_interval\", \"ki\");\n        return this;\n    }\n    ocr(value) {\n        this.param(value, \"ocr\", \"ocr\");\n        return this;\n    }\n    offset(value) {\n        var end_o, start_o;\n        [start_o, end_o] = (isFunction(value != null ? value.split : void 0)) ? value.split('..') : Array.isArray(value) ? value : [null, null];\n        if (start_o != null) {\n            this.startOffset(start_o);\n        }\n        if (end_o != null) {\n            return this.endOffset(end_o);\n        }\n    }\n    opacity(value) {\n        this.param(value, \"opacity\", \"o\", Expression.normalize);\n        return this;\n    }\n    overlay(value) {\n        this.layerParam(value, \"overlay\", \"l\");\n        return this;\n    }\n    page(value) {\n        this.param(value, \"page\", \"pg\");\n        return this;\n    }\n    poster(value) {\n        this.param(value, \"poster\");\n        return this;\n    }\n    prefix(value) {\n        this.param(value, \"prefix\", \"p\");\n        return this;\n    }\n    quality(value) {\n        this.param(value, \"quality\", \"q\", Expression.normalize);\n        return this;\n    }\n    radius(value) {\n        this.arrayParam(value, \"radius\", \"r\", \":\", Expression.normalize);\n        return this;\n    }\n    rawTransformation(value) {\n        this.rawParam(value, \"raw_transformation\");\n        return this;\n    }\n    size(value) {\n        let height, width;\n        if (isFunction(value != null ? value.split : void 0)) {\n            [width, height] = value.split('x');\n            this.width(width);\n            return this.height(height);\n        }\n    }\n    sourceTypes(value) {\n        this.param(value, \"source_types\");\n        return this;\n    }\n    sourceTransformation(value) {\n        return this.param(value, \"source_transformation\");\n    }\n    startOffset(value) {\n        this.rangeParam(value, \"start_offset\", \"so\");\n        return this;\n    }\n    streamingProfile(value) {\n        this.param(value, \"streaming_profile\", \"sp\");\n        return this;\n    }\n    transformation(value) {\n        this.transformationParam(value, \"transformation\", \"t\");\n        return this;\n    }\n    underlay(value) {\n        this.layerParam(value, \"underlay\", \"u\");\n        return this;\n    }\n    variable(name, value) {\n        this.param(value, name, name);\n        return this;\n    }\n    variables(values) {\n        this.arrayParam(values, \"variables\");\n        return this;\n    }\n    videoCodec(value) {\n        this.param(value, \"video_codec\", \"vc\", Param.process_video_params);\n        return this;\n    }\n    videoSampling(value) {\n        this.param(value, \"video_sampling\", \"vs\");\n        return this;\n    }\n    width(value) {\n        this.param(value, \"width\", \"w\", () => {\n            if (this.getValue(\"crop\") || this.getValue(\"overlay\") || this.getValue(\"underlay\")) {\n                return Expression.normalize(value);\n            }\n            else {\n                return null;\n            }\n        });\n        return this;\n    }\n    x(value) {\n        this.param(value, \"x\", \"x\", Expression.normalize);\n        return this;\n    }\n    y(value) {\n        this.param(value, \"y\", \"y\", Expression.normalize);\n        return this;\n    }\n    zoom(value) {\n        this.param(value, \"zoom\", \"z\", Expression.normalize);\n        return this;\n    }\n}\n/**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n */\nconst methods = [\n    \"angle\",\n    \"audioCodec\",\n    \"audioFrequency\",\n    \"aspectRatio\",\n    \"background\",\n    \"bitRate\",\n    \"border\",\n    \"color\",\n    \"colorSpace\",\n    \"crop\",\n    \"customFunction\",\n    \"customPreFunction\",\n    \"defaultImage\",\n    \"delay\",\n    \"density\",\n    \"duration\",\n    \"dpr\",\n    \"effect\",\n    \"else\",\n    \"endIf\",\n    \"endOffset\",\n    \"fallbackContent\",\n    \"fetchFormat\",\n    \"format\",\n    \"flags\",\n    \"gravity\",\n    \"fps\",\n    \"height\",\n    \"htmlHeight\",\n    \"htmlWidth\",\n    \"if\",\n    \"keyframeInterval\",\n    \"ocr\",\n    \"offset\",\n    \"opacity\",\n    \"overlay\",\n    \"page\",\n    \"poster\",\n    \"prefix\",\n    \"quality\",\n    \"radius\",\n    \"rawTransformation\",\n    \"size\",\n    \"sourceTypes\",\n    \"sourceTransformation\",\n    \"startOffset\",\n    \"streamingProfile\",\n    \"transformation\",\n    \"underlay\",\n    \"variable\",\n    \"variables\",\n    \"videoCodec\",\n    \"videoSampling\",\n    \"width\",\n    \"x\",\n    \"y\",\n    \"zoom\"\n];\n/**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n */\nconst PARAM_NAMES = methods.map(snakeCase).concat(CONFIG_PARAMS);\nexport default Transformation;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}